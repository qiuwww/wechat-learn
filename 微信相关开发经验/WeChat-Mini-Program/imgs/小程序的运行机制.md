# 小程序的运行机制

[参考文章](https://godbasin.github.io/2018/09/02/wxapp-technology-architecture/)

## 一切始于双线程

目前来说，页面渲染的方式主要有三种：

- Web 渲染。
- Native 原生渲染。
- Web 与 Native 两者掺杂，也即我们常说的 **Hybrid 渲染**。

前面也说过，小程序最终的呈现形式，是 **WebView + 原生组件**，**Hybrid 方式**。

## 问题的产生

如果用**纯 Web 技术**来渲染小程序，在一些有**复杂交互的页面**上可能会面临一些性能问题。

这是因为**在 Web 技术中，UI 渲染跟 JavaScript 的脚本执行都在一个单线程中执行(避免内存泄露)**，这就容易导致一些逻辑任务抢占 UI 渲染的资源。

## 小程序的双线程

小程序的**渲染层**和**逻辑层**分别由 2 个线程管理：

- 渲染层的界面使用了 WebView 进行渲染，
- 逻辑层采用 JsCore 线程运行 JS 脚本。

我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。通过提供一个**沙箱环境**来运行开发者的 JavaScript 代码来解决。

这个沙箱环境只提供**纯 JavaScript 的解释执行环境**，没有任何浏览器相关接口。

这就是小程序双线程模型的由来，双线程。

- 逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序**业务逻辑的代码**；
- 渲染层：**界面渲染相关的任务全都在 WebView 线程里执行**，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。

## 双线程通信

逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。

1. 在渲染层把 WXML 转化成对应的 JS 对象。

2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。

3. 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。

## 小程序的基础库

小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。

## Exparser 框架

Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。

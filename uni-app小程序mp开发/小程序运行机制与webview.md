# 小程序相关

## 运行机制

1. 前台后台：
   1. 前台：界面被展示给用户；
   2. 后台：小程序还可以短暂运行一小段时间，**但部分 API 的使用会受到限制**。
2. 切后台 5s 后会被**挂起**：
   1. 微信会停止小程序 JS 线程的执行；
   2. 此时**小程序的内存状态会被保留**，但开发者代码执行会停止，事件和接口回调会在小程序再次进入「前台」时触发；
   3. 当开发者使用了后台音乐播放、后台地理位置等能力时，**小程序可以在「后台」持续运行，不会进入到「挂起」状态**；
3. 挂起 30min 后会被**销毁**：
   1. 如果用户很久没有使用小程序，或者系统资源紧张，小程序会被「销毁」，即完全终止运行。
4. 启动方式：
   1. 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动；
   2. 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。
5. 重新启动策略：
   1. restartStrategy 配置项可以改变这个默认的行为，使得**从某个页面退出**后，下次 A 类场景的冷启动可以回到这个页面。
6. 退出状态：
   1. 每当小程序可能被销毁之前，页面回调函数 onSaveExitState 会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过 exitState 获得这些已保存数据。

## 小程序 webview 实践（H5 多端兼容方案）

1. 小程序内如何嵌入 H5：
   1. 能实现**一套代码在多端运行**；
2. 很多**营销活动**：
   1. 借助微信的庞大用户群，小程序是一个很好的获客渠道；
3. 对比小程序原生与 H5:
   1. 小程序原生：
      1. 优点：体验好，速度快；
      2. 缺点：**不灵活**，需要发包审核，包的体积会逐步增大；
      3. **存量 H5 的问题**：都改造成小程序的成本太高了；
   2. 小程序+H5:
      1. 优点：灵活，工作量比较小；
      2. 缺点：**交互，通信成本高**；
      3. **存量 H5 的问题**：与 APP 功能耦合严重；
   3. 多端编译，比如从头 taro/uni-app 开发；
      1. 优点：多端运行，多端性能都还可以；
      2. 缺点：api 兼容成本高，会进行很多判断，会有很多代码；
         1. 编译出来的结果不是特别理性，一是性能上面没有达到理想的状态，二是 api 在多端兼容上面二次改造的成本很高；
      3. **存量 H5 的问题**：与 APP 功能耦合严重；
4. 最终取舍：
   1. 目前我们的**小程序是作为一个端存在，像 app 一样**，
   2. 我们只做首页、列表、详情、购买等等核心页面都是用小程序开发，
   3. **每个业务的页面、活动运营页面都是 H5**，并且用 webview 嵌入，这样各个业务接入的成本非常低，但这也有缺点：
      1. 一是小程序与 h5 交互和通信比较麻烦，
      2. 二是我们的 app 提供了很大功能支持，这些功能在小程序里面都需要对应的实现。
5. webview 与小程序对比，webview 的优缺点：
   1. 离线能力比较弱；
   2. 页面切换体验一般；
   3. 首屏速速，如果使用 ssr 还是不错的，但是目前大部分项目还不是；
   4. 二次渲染速度比较高，有缓存；
      1. 如何处理缓存？
         1. [彻底解决小程序内嵌 web-view 缓存问题](https://juejin.cn/post/6948800156405858335)；
            1. url 添加时间戳，非 hash 的参数；
            2. 在 index.html 的 head 头部添加不缓存的配置；
            3. 在 webpack 打包的时候给资源加上 hash 配置；
            4. 使用工具 debugtbs：如果是安卓机， 可以在微信上打开`http://debugtbs.qq.com`；
         2. 设置 cache-control 来关闭浏览器缓存 && webpack 打包的时候加上 hash 配置；
         3. 添加 query，可以解决 ios 的缓存问题，但是 android 还是不行；
            1. 这里选择的做法就是添加了 query 为时间戳；
   5. 列表性能高；
   6. 开发灵活；
   7. api 能力一般；
6. H5 兼容多端的操作：
   1. 使用 adapter 来处理 H5 运行在公众号、小程序、app 内的问题；
      1. 主要有分享、登陆、通信等；
      2. adapter 初始化，检测不同的环境，来异步加载对应的 sdk；
         1. adapter 的原理，首先 adapter 需要初始化，做两件事情，
            1. 一是产出一个供 h5 调用的 native 对象，
            2. 二是需要**检测当前所处的环境**；
            3. 打包出来的结果`adapt.min.js`；
               1. 这里的关键点是**我们要做个 api 调用的队列，因为 sdk 加载时异步的过程，如果期间页面内发生了 api 调用，那肯定得不到正确的响应，因此你要做个调用队列，当 sdk 初始化完毕之后再处理这些调用**，其实 adapter 原理很简单，如果你想实现多端适配，那么**只需要根据所在的环境去加载不同的 sdk 就可以了**。
            4. 做好 adapter 之后，你需要让每个 h5 的项目都引入 adapter 文件，并且在调用 api 的时候，都统一在 native 对象下面调用。
7. 区分环境：
   1. adapter：adapt/src/utils/env.ts
8. 订阅消息：zyjk-mini-program/src/pages_independent2/pages/subscribe/index.vue
9. 小程序支付：统一的支付页面；
10. **formId 收集**：
    1. webview 里面没有办法收集 formId；
    2. 想实现这种小程序的模板消息，就必须要获取用户的 formid 才可以；
    3. 没有 formId 就没法发服务通知，没有服务通知，业务就没办法对新用户进行召回，**这对业务来讲是一个很大的损失**；
    4. 主要通过两种方式收集，
       1. 访问量比较大的这种 webview 落地页，**我们会做一版小程序的页面或者做一个小程序的中转页**，只要用户有任何触摸页面的操作，都可以收集到 formid，
       2. 另外一种就是 **h5 进入小程序页面时候收集**，**比如支付，IM 这些页面，但并不是每个用户都会进到这些页面的**，用户可能一进来看不感兴趣，就直接退出了，因此这种方式存在很大的流失。

## 参考

1. [小程序运行机制](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html)；
2. [小程序 webview 实践](https://www.cnblogs.com/zhuanzhuanfe/p/9754482.html)
